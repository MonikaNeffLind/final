---
title: "Script"
author: "Kathryn Denning, Karlena Ochoa, Jenn Lewis, Tamara Niella"
date: "5/14/2019"
output: html_document
---

```{r setup}
library(tidyverse)
library(rio)
library(here)
library(stringr)
#install.packages("splitstackshape")
library(splitstackshape)
library(magrittr)

data <- import(here("data", "movie_metadata.csv_movie_metadata.csv"))

data <- data %>%
  mutate(gross = as.numeric(gross),
         budget = as.numeric(budget),
         profit = gross-budget)
```

```{r Custom Function 1}
#Make a function that tells you the average imdb rating for a specfic actor; this function will only work within this data set

average_imdb <- function(x) {
 df <- aggregate(imdb_score ~ actor_1_name, data, mean)
 
 row.names(df) <- df$actor_1_name 
 
 df[x,"imdb_score"]
    }

#Test function, provide actor name in quotes to get their average imdb_score

average_imdb("Tom Cruise")
average_imdb("Johnny Depp")
average_imdb("Will Smith")

```

```{r Custom Function 2}
#Create a custom function that will pull out descriptive statistics for a variable

descriptives <- function(x) {
  data.frame(mean(x), sd(x), min(x), max(x), length(x))
  }

#Test if it works
descriptives(data$imdb_score)
```

```{r}

# let's nest our data by genre

df_genre <- data %>% 
  drop_na()%>%
  group_by(genres)%>%
  nest()

# let's nest our data by country 

df_country <- data %>% 
  drop_na() %>%
  group_by(country)%>%
  nest()

# Country seems to be a more reasonable grouping variable to work with - In genres there seems to be a lot of combinations of different genres. but let's take a look at the number of observations per group for the two different categories 

map(df_country$data, ~length(.x[[1]]))
map(df_genre$data, ~length(.x[[1]]))
```

For both categories there seems to be a very uneven number of observations per group. However, in genres this might be due to the fact that there are a lot of combinations. I am going to go ahead and use a criteria to determine the genre of the movie as the first genre that appears in the combination, and then I will nest the data again according to this new criteria (I will consider the other genres within the same genre as "sub-genres")

```{r}
#let's separate the combination of genres for each movie and keep the first genre as main genre in a new variable

data_new <- data%>%
  drop_na()


data_new<- cSplit(data_new, "genres", "|")

data_new %<>% rename(main_genre = genres_1)

#now let's nest data by main genre 

df_main_genre <- data_new%>% 
  select(-genres_2, -genres_3, -genres_4, -genres_5, -genres_6, -genres_7, -genres_8)%>%
  group_by(main_genre)%>%
  nest()



```

Now let's map through the list to run a regression predicting profit from number of facebook likes for the movie 

```{r}

map(df_main_genre[[2]], ~lm(profit~movie_facebook_likes, .x))

#but actually, I think it might be better if I bouild that data fram as a list of lists 

#season to wave 
df_mg_list <- data_new %>%
  select(-genres_2, -genres_3, -genres_4, -genres_5, -genres_6, -genres_7, -genres_8)%>%
    as_tibble()


by_main_genre <- split(df_mg_list, df_mg_list$main_genre)


model <- map(by_main_genre, ~lm(profit ~ movie_facebook_likes, .x))

#model

coefs <- map(model, ~coef(.x))

slopes <- map_dbl(coefs, 2)



# I think splitting works better for this then nesting, but I'm leaving both methods for now, and then wecan decide if we want to keep one or the other or both 

```



```{r map 2 to get model comparisons}
# As seen above, you can use map to extract the coefficients separately, but what if we wanted to do that AND extract the ses all at once? That's where map2 comes in!

# compare model 1 vs model 2, model 2 adds a second predictor (imbd score) to see if there is a better fit

model2 <- map(by_main_genre, ~lm(profit ~ movie_facebook_likes + imdb_score, .x))

# Trying to get our two models into a tibble that we can then compare the models and plot
## getting error that tibble columns are not the same length
## also, when we use map, we got an error that mutate wouldn't work on a list column
model_comparison_df <- by_main_genre %>% 
  as_tibble() %>% 
  mutate(m1 = map(data, ~lm(profit ~ movie_facebook_likes, .x)),
         m2 = map(data, ~lm(profit ~ movie_facebook_likes + imdb_score, .x)))

# Eventually use map2 to pull out r^2 change to then plot

#Based on Daniels suggestion 
model_comparison_df <- by_main_genre %>% 
  bind_rows(.id = "genre") %>% 
  group_by(genre) %>% 
  nest() %>% 
  mutate(m1 = map(data, ~lm(profit ~ movie_facebook_likes, .x)),
         m2 = map(data, ~lm(profit ~ movie_facebook_likes + imdb_score, .x)))

model_comparison_df$m1[[1]]

#model comparison 
compare_modelfit <- anova(model_comparison_df$m1[[1]], model_comparison_df$m2[[1]])

compare_all <- model_comparison_df %>%
    mutate(comp12 = map2(m1, m2, anova))

```

```{r messing with coefficients}
# getting the slopes for model 1
slopes1 <- map_df(coefs, 2)
slopes1 %<>% 
  gather(movie_title, slopes_m1)

# getting the intercepts for model 1
intercepts1 <- map_df(coefs, 1)
intercepts1 %<>%
  gather(movie_title, intercepts_m1)

# getting the slopes for model 2
coefs2 <- map(model2, ~coef(.x))
slopes2 <- map_df(coefs2, 2)
slopes2 %<>% 
  gather(movie_title, slopes_m2)

# getting the intercepts for model 2
intercepts2 <- map_df(coefs2, 1)
intercepts2 %<>%
  gather(movie_title, intercepts_m2)

# merging the dataframes together

join_model1 <- left_join(intercepts1, slopes1)
join_model2 <- left_join(intercepts2, slopes2)
models_combined <- left_join(join_model1, join_model2)
```
